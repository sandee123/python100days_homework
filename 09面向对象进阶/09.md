#### @property装饰器
想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作
使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便
```python
class Person(object):
    def __init__(self, name, age):
        self._name = name
        self._age = age

    # 访问器 - getter方法
    @property
    def name(self):
        return self._name

    # 访问器 - getter方法
    def age(self):
        return self._age

    # 修改器 - setter方法
    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        if self._age <= 16:
            print('%s正在玩飞行棋' % self._name)
        else:
            print('%s正在玩斗地主' % self._name)

def main():
    person = Person('王大锤', 12)
    person.play()
    person.age = 22
    person.play()
    # person.name = '白元芳' # AttributeError: can't set attribute

if __name__ == '__main__':
    main()
```

#### \_\_slots__
 通过定义__slots__变量来限定自定义类型的对象只能绑定某些属性。
 需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。

```python
class Person(object):
    # 限定Person对象只能绑定_name,_age和_gender属性
    __slots__ = ('_name', '_age', '_gender')
    
    def __init__(self,name,age):
        self._name = name
        self._age = age

    @property
    def name(self):
        return self._name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        if self._age <= 16:
            print('%s正在玩飞行棋。' % self._name)
        else:
            print('%s正在玩斗地主。' % self._name)

def main():
    person = Person('xx', 22)
    person.play()
    person._gender = 'man'
    # AttributeError: 'Person' object has no attribute '_is_gay'
    # person._is_gay = True
```

#### 静态方法和类方法
实例方法只能被实例对象调用，静态方法(由@staticmethod装饰的方法)、类方法(由@classmethod装饰的方法)，可以被类或类的实例对象调用。
实例方法，第一个参数必须要默认传实例对象，一般习惯用self。
静态方法，参数没有要求。
类方法，第一个参数必须要默认传类，一般习惯用cls。

























